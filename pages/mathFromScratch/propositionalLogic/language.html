<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="../../../style.css">
    <link rel="icon" sizes="125x99" href="../../../images/GameSolver.png?v=3" type="image/png">
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <!-- MathJax Configuration -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['\\[', '\\]'], ['$$', '$$']]
            },
            TeX: {
                Macros: {
                    // Define \bigcomp as a large operator similar to \sum
                    bigcomp: ["\\mathop{\\huge\\circ}\\limits", 0]
                    //bigcomp: ["\\mathop{\\scalebox{2.0}{\\circ}}\\limits", 0]
                }
            }
        });
    </script>
    <title>Language</title>
</head>
<body>
    <main>
        <nav class="sidebar">
            <div class="sidebar-links">
                <a title="Math From Scratch" href="../../mathFromScratch.html">Table of Contents</a>
                <a title="The Very Beginning" href="../theVeryBeginning.html">0. The Very Beginning</a>
                <a title="Syntax" href="../syntax.html">1. Syntax</a>
                <a title="Propositional Logic" href="../propositionalLogic.html">2. Propositional Logic</a>
                <a title="Propositional Logic | Language" href="language.html">2.1 Language</a>
                <a title="Propositional Logic | Semantics" href="semantics.html">2.2 Semantics</a>
                <a title="Propositional Logic | Propositional Calculus" href="propositionalCalculus.html">2.3 Propositional Calculus: \(P_2\)</a>
                <a title="Propositional Logic | Soundness Theorem" href="soundnessTheorem.html">2.4 Soundness Theorem</a>
                <a title="Propositional Logic | Useful Theorems, Lemmas and Metatheorems" href="usefulTheoremsLemmasAndMetatheorems.html">2.5 Useful Theorems, Lemmas and Metatheorems</a>
            </div>
        </nav>
        <article class="post">
            <section>
                <h1 class="top-title">2.1 Language</h1>
                <hr>
            </section>
            <section>
                <p>
                    In this chapter, I'll present a suitable formal language for propositional logic. Its alphabet consists of
                </p>
                <ul>
                    <li>
                        <strong>statement letters</strong>/<strong>elementary proposition symbols</strong>: capital letters from 
                        the English anguage (\(A\), \(B\), \(C\), ...), Greek letters (\(\alpha\), \(\beta\), \(\gamma\), ...) 
                        and those kinds of letters with subscripts (\(A_1\), \(\alpha_1\), \(\varphi_{42}\), ...)
                    </li>
                    <li>
                        <strong>logical connective symbols</strong>: \(\neg\), \(\land\), \(\lor\), \(\oplus\), \(\rightarrow\), 
                        \(\leftrightarrow\), \(\leftarrow\), \(\uparrow\), \(\downarrow\), \(\not\rightarrow\), 
                        \(\not\leftrightarrow\) and \(\not\leftarrow\)

                    </li>
                    <li>
                        <strong>parenthesis</strong>: ( and )
                    </li>
                </ul>
                <p>
                    This language has no terms and wffs are only one of the following:
                </p>
                <ul>
                    <li>statement letters, or</li>
                    <li>
                        the open parenthesis symbol ( followed by the \(\neg\) symbol followed by a wff followed by the close 
                        parenthesis symbol ), or
                    </li>
                    <li>
                        the open parenthesis symbol ( followed by a wff followed by a logical connective symbol other than 
                        "\(\neg\)" followed by a wff followed by the close parenthesis symbol )
                    </li>
                </ul>
                <p>
                    Any wff containing at least one logical connective symbol is called a compound statement/proposition and the 
                    statement/s the connective applies to is/are called its substatement/s.
                </p>
                <p> <u><strong>Remarks:</strong></u> </p>
                <ul>
                    <li>
                        Normally, I should put the symbols inside quotation marks or in italic to specify that they are elements 
                        of the object language, but to simplify the writing I'm assuming you are aware what symbols I'm talking 
                        about
                    </li>
                    <li>
                        From here on, to simplify the writing I'll omit the word "symbol/s" from "elementary proposition 
                        symbol/s" and "logical connective symbol/s" when referring to them
                    </li>
                    <li>
                        "\(\neg\)" is called a unary connective and all the other connectives of this language are called binary
                    </li>
                    <li>
                        To aleviate the reading, I may use other types of parenthesis, as [ and ], or I may write them with 
                        different sizes. To convert to a proper wff, simply replace such open parenthesis by ( and close 
                        parenthesis by )
                    </li>
                    <li>
                        Variables are placeholders/abbreviations for mathematical objects. In the context of Mathematical Logic, 
                        metavariables are metalinguistical variables that are placeholders for wffs from the formal language. As 
                        an abuse of language, I may use elementary proposition symbols for metavariables instead, so whenever 
                        that happens, it shall be specified beforehand
                    </li>
                </ul>
                <br>
                <h2> <u>Parenthesis</u> </h2>
                <p>
                    In order to render notation less cumbersome, we are going to agree on some metalinguistical conventions to 
                    eliminate parenthesis when referring to wffs. First, we may omit the outer pair of parentheses of a wff that 
                    isn't a statement letter. Second, we define an order of precedence for the connectives (from highest to 
                    lowest):
                </p>
                <ol>
                    <li>\(\neg\)</li>
                    <li>\(\land\)</li>
                    <li>\(\lor\)</li>
                    <li>
                        \(\oplus\), \(\uparrow\), \(\downarrow\)
                    </li>
                    <li>
                        \(\rightarrow\), \(\leftarrow\), \(\leftrightarrow\), \(\not\rightarrow\), \(\not\leftarrow\), 
                        \(\not\leftrightarrow\)
                    </li>
                </ol>
                <p>
                    Now, letting \(A\) and \(B\) be metavariables, here's a step-by-step process to restore parenthesis given 
                    this order of precedence:
                </p>
                <ol>
                    <li>Find the leftmost occurrence of the strongest connective that has not yet been processed (i.e. the 
                        strongest connective whose compound wff isn't yet surrounded by paranthesis)</li>
                    <li>If its wff is of the form \(\neg A\), convert it to \((\neg A)\)</li>
                    <li>
                        If \(A \circ B\) is of the form \(\varphi_1 \circ...\circ \varphi_{n-1} \circ \varphi_n\), where the 
                        same logical connective \(\circ\) appears \(n\) times (at least once) in sequence and in the variables
                        \(\varphi_k\), \(k\) ranges from 1 to \(n+1\), from right to left convert 
                        \(\varphi_k \circ \varphi_{k+1}\) to \((\varphi_k \circ \varphi_{k+1})\) for all \(k\) between 1 and 
                        \(n-1\)
                    </li>
                </ol>
                <p> <u><strong>Remarks:</strong></u> </p>
                <ul>
                    <li>
                        This order of precedence is purely conventional/arbitrary. We could agree on any order of precedence as 
                        long as we are in possession of an algorithm to rediscover the original wff from the abbreviated one
                    </li>
                    <li>
                        This comment is for those who are not familiar with algebra or with the practice of using letters as 
                        variables to denote numbers (for those familiar with the existence of various number systems, here by 
                        numbers, I specifically mean natural numbers): here we used the letters \(n\) and \(k\) to denote numbers, 
                        \(n+1\) for the number that comes after \(n\) and \(n-1\) for the number that comes before \(n\), as is 
                        common practice in the mathematical litterature. Any other letters could have been used instead of \(n\) 
                        and \(k\) and it should always be clear from the context (blame the author otherwise) when letters are 
                        used to denote numbers
                    </li>
                </ul>
                <p>
                    Another thing I could have done, this time to completely eliminate parenthesis from our language, would be to 
                    define wffs otherwise, through the use of Polish notation. In Polish notation, a wff would be
                </p>
                <ul>
                    <li>a statement letter, or</li>
                    <li>\(\neg\) followed by a wff, or</li>
                    <li>a binary connective followed by two wffs</li>
                </ul>
                <p>
                    Polish notation may be harder for us humans to read, but it is much more compact. Thus, it would be a more 
                    suitable notation to define the length of wffs, if we were to study it.
                </p>
                <br>
                <h2> <u>Sigma notation</u> </h2>
                <p>
                    Sigma notation is another metalinguistical notation that we'll use to abbreviate the writing of wffs.
                </p>
                <p>
                    Let \(\circ\) denote a binary logical connective. Whenever one has expressions of the form 
                    \(\neg\neg...\neg A\) or \(A_1 \circ A_2 \circ...\circ A_n\), where the same connective appears \(n\) times 
                    (at least once) in sequence in a wff and in the variables \(A_i\), \(i\) ranges from 1 to \(n+1\) in that 
                    order, one may instead respectively write \(\mathop{\huge\neg}\limits_{i=1}^nA\) or 
                    \(\bigcomp\limits_{i=1}^{n+1}A_i\).
                </p>
            </section>
            <section>
                <br>
                <hr>
                <div style="text-align: center; margin-top: 20px; font-style: italic; display: flex; justify-content: center;">
                    <p style="margin: 0;">
                        <i>Posted 30/08/2024 | Last edited 06/09/2024</i>
                    </p>
                </div>
            </section>
        </article>
    </main>
</body>
</html>